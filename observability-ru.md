Original Observability Whitepaper [here](https://github.com/cncf/tag-observability/blob/whitepaper-v1.0.0/whitepaper.md).


# Whitepapaer по наблюдаемости
Добро пожаловать в разработанную сообществом версию 1.0 White Paper по наблюдаемости. Под руководством TAG Observability в экосистеме CNCF она была выпущена в октябре 2023 года.
Эта версия — только начало! Есть еще много тем для освещения и вещей, которые можно добавить.

См. [раздел о внесении изменений](https://github.com/cncf/tag-observability/blob/whitepaper-v1.0.0/whitepaper.md#contributing) в эту книгу и помощи нам в расширении этой базы знаний для всех пользователей CNCF.

## Краткое содержание
С постоянным ростом сложности систем и данных, которые мы обрабатываем каждую секунду, нам нужна лучшая наблюдаемость (observability), чтобы понимать состояние наших рабочих нагрузок. Помимо инструментов наблюдаемости, теперь все чаще ожидается, что каждый инженер, отвечающий за запуск своего программного обеспечения как услуги, будет понимать, как контролировать и наблюдать за своими приложениями. С более высокими ожиданиями клиентов и более строгими целями уровня обслуживания (SLO) инженеры должны находить первопричины проблем и устранять их быстрее, чем когда-либо.

Цель документа — помочь разобраться в основах нативной облачной наблюдаемости. Мы дадим общий обзор различных видов и шаблонов для наблюдаемости, которые вам могут понадобиться при работе с рабочими нагрузками в облаке.

## Введение
С популяризацией облачных вычислений, микросервисов и распределенных систем новые приложения часто проектируются и создаются для работы в облаке. Хотя это обеспечивает новые стратегии для создания более устойчивых, более производительных и более безопасных приложений, это сопряжено с потенциальной ценой потери контроля над инфраструктурой, поддерживающей эти рабочие нагрузки. Системные администраторы, разработчики и операторы программного обеспечения должны знать как о состоянии приложения в production, так и о состоянии базовой инфраструктуры, на которой это приложение работает. Также у них должна быть возможность наблюдать эти сигналы со стороны без необходимости включать, например, дополнительный инструментарий в исходный код или устанавливать контрольные точки (breakpoints) на работающий в production код.

Приложения должны быть спроектированы и созданы так, чтобы включать и облегчать механизмы, которые делают их наблюдаемыми для некоторой сущности, и не важно, является ли эта сущность другим приложением или человеком без доступа к центру обработки данных. Усилия должны быть предприняты на раннем этапе, начиная с проектирования, и часто это требует дополнительного кода или автоматизации инфраструктуры и инструментария. Эти культурные и процессные изменения часто являются проблемами или блокировщиками для многих организаций. Вдобавок ко всему, многие методы и инструменты на рынке предлагают различные подходы для достижения разумного уровня наблюдаемости.

Как только достигается удовлетворительный уровень наблюдаемости, нет никаких сомнений в его преимуществах, но начало может показаться пугающим! Культурные изменения, разные инструменты, разные цели, разные методы. Так много деталей, которые необходимо учитывать, могут сделать этот путь запутанным и болезненным. Целью данного материала является внесение ясности, чтобы большее количество групп разработчиков программного обеспечения и эксплуатации могли воспользоваться преимуществами наблюдаемости в своих системах.

## Целевая аудитория
Целевая аудитория этой статьи:

- Инженеры по надежности (SRE)
- Инженеры DevOps
- Системные администраторы
- Инженеры программного обеспечения
- Инженеры инфраструктуры
- Разработчики программного обеспечения

Эта статья относится к любой из вышеперечисленных ролей в организациях, которые хотят поставлять наблюдаемое программное обеспечение, которое интегрируется с существующими observability-системами их клиентов, достигая при этом демонстрируемого уровня надежности, безопасности и прозрачности. Дополнительные заинтересованные стороны, такие как менеджеры проектов, продуктов, программ и архитекторы, ответственные за проектирование и реализацию такого программного обеспечения, также могут быть заинтересованы в этой статье, поскольку наблюдаемость является междисциплинарной темой. Студенты компьютерных наук, информационных систем и инженерии (или смежных специальностей) и люди, интересующиеся областью наблюдаемости, также могут найти полезную информацию в этой статье.

## Цели
Внедрение облачных вычислений помогло малым и крупным технологическим компаниям оптимизировать затраты, масштабировать и разрабатывать более эффективные продукты, но это принесло и ряд проблем. Так как инфраструктура стала удаленной, временной и глобально распределенной, системные администраторы потеряли контроль над ЦОДами. Компании, которые когда-то имели культуру, в которой администраторы и разработчики имели противоречивые цели, должны перейти на новую культуру, в которой они теперь должны работать вместе как единая команда, стремясь создать надежное программное обеспечение. Несколько новых стратегий и инструментов появились в результате наблюдения за состоянием Cloud Native систем, которые помогают компаниям поддерживать надежность систем в этой новой реальности.

Во время проектирования и разработки наблюдаемой системы она должна быть оснащена инструментами для отправки или предоставления телеметрических данных третьей стороне, обычно набором инструментов, отвечающих за предоставление значимой информации из предоставленных данных. Альтернативой может быть автоинструментирование, например, через среду выполнения Java, pprof или eBPF. Эти телеметрические данные часто поступают в виде метрик и логов, трассировок, структурированных событий, профилей и аварийных дампов, которые давно используются командами разработчиков программного обеспечения. Каждый тип имеет свою цель и лучшие практики, и их неправильное использование может привести к новым проблемам при запуске программного обеспечения в большом масштабе, например таким, как усталость от алертов и высокая стоимость.

Несмотря на то, что есть несколько новых проблем, таких как изменение культуры, планирование мощностей, юридические вопросы и другие, многие из них уже были решены инновационными компаниями, которые рано вошли в эту новую эру. Новички могут воспользоваться их опытом и лучшими практиками для решения аналогичных проблем. В этом документе пойдет речь о разнице между типами сигналов наблюдаемости и тем, как их следует обрабатывать, перечислены несколько различных методов, которые успешные компании использовали при решении распространенных проблем, представлены несколько инструментов, которые попадают в область наблюдаемости, и об их месте в вашем  observability-стеке, а также показаны общеизвестные проблемы, которые все еще не решены или методы их решения еще не очень хорошо устоялся в отрасли.

## "Не цели"
Этот документ не предназначен для предоставления низкоуровневых руководств по установке или подробностей конфигурации для конкретных проектов в области наблюдаемости. Он также не предназначен для подробного глубокого погружения в различные стандарты, такие как распространение контекста W3C, формат Prometheus Exposition (OpenMetrics) или протокол OpenTelemetry (OTLP).

Вместо этого вам предлагается общий обзор и приводятся ссылки на полезные материалы — документацию к проектам.

# Что такое "Наблюдаемость"?
Нет сомнений, что наблюдаемость — это желательное свойство системы. Все так говорят, верно? Некоторые из вас, возможно, уже начали свой путь в области наблюдаемости, в то время как другие читают этот технический документ прямо сейчас только потому, что все говорят, что вам следует сделать свои системы наблюдаемыми. Правда в том, что "наблюдаемость" стала модным словом. Как и в случае с другими хайповыми понятиями, каждый считает своим долгом "оставить свой след", не всегда разбираясь в сути. Если вы действительно решили, что наблюдаемость — это всерьез и надолго, давайте попробуем прояснить ее базовую суть.

В теории управления (Kalman R. E., On the General Theory of Control Systems, Proc. 1st Int. Cong. of IFAC, Moscow 1960 1481, Butterworth, London 1961. https://www.sciencedirect.com/science/article/pii/S1474667017700948?via%3Dihub) наблюдаемость — мера того, насколько хорошо внешняя информация о системе позволяет судить о ее внутреннем состоянии. Если поменьше теории - это функция системы, с помощью которой люди и машины могут наблюдать, понимать и воздействовать на состояние указанной системы. Определение наблюдаемости выглядит достаточно просто, но при реализации без конкретной цели бывает сложно решить, какой выход (output) должна иметь система. Тут и возникают сложности.

Когда вы начинаете, использовать результаты чужой работы легко. Это одно из благословений и, одновременно, одно из проклятий Open Source. В сети есть много примеров: Helm Charts, Ansible Playbooks, модули Terraform. Можно просто запустить один из этих скриптов, и у вас будет готовый и работающий стек наблюдаемости всего за несколько минут. Это легко, и это просто работает. Вы должны не просто использовать эти скрипты, но и помнить, что наблюдаемость — это не просто использование всех "красивых и блестящих" инструментов. Вы должны осознавать, какие выходные данные выдает ваша система, и, что важнее всего, вам нужно иметь конкретную цель в голове! Большинство думает, что "О, я хочу собрать вообще все, что возможно, может, оно пригодится мне в будущем". Но подобный подход приводит только к созданному переизбытку ненужных данных.

Наблюдаемость нужна буквально на всех этапах жизненного цикла разработки системы. Ее можно использовать для тестировании новой функции, мониторинга устойчивости production, сбора сведений о том, как ваши клиенты используют ваш продукт, или для принятия data driven решений о roadmap вашего продукта. Определившись с целями можно начинать думать о "выходах", или, как мы их называем, сигналах.

## Observability-сигналы
Сигналы — это выходные данные системы, по которым человек или машина может сделать вывод о ее состоянии. Эти сигналы будут различаться от системы к системе и зависеть от цели, которую вы хотите достичь. Это может быть что-то, что вы хотите измерить в определенный момент времени, например, температура или использование ОЗУ, или событие, которое проходит через многие компоненты вашей распределенной системы, которое вы хотите отследить. Возможно, вам захочется узнать, какая функция вашей системы наиболее интенсивно использует ресурсы, такие как ЦП, память или диск, в случайный момент времени или что происходило в момент аварии в вашей системе. Некоторые сигналы могут пересекаться, некоторые специализируются на определенных аспектах системы. Все они могут использоваться вместе, чтобы обеспечить различные способы наблюдения за одной и той же частью системы, или, как мы рекомендуем для начала, вы можете начать с одного или нескольких и постепенно добавлять остальные.

Вероятно, вы слышали о "трех столпах наблюдаемости" - метриках, логах и трассировках. Они самые популярные и, вероятно, с них вы начнете. Но мы предпочитаем называть их "первичными сигналами", а не как о "трех столпах" по двум причинам:

Понятие "столпы" предполагает, что при исчезновении какого-то одного "столпа" вся контрукция рухнет, но на самом деле это не так. Они не всегда требуются одновременно, можно использовать один или два и при этом достичь своей цели по наблюдаемости, да еще и сэкономив. В последнее время в Open Source сообществах становятся популярными такие сигналы, как непрерывное профилирование приложения и аварийные дампы. Новые сигналы с новой семантикой также могут появиться в ближайшем будущем, и тем, кто интересуется этой темой, следует следить за ними.


![На рисунке 1 показаны три основных сигнала. Обратите внимание, что не все метрики семантически агрегируемы, но обычно их можно агрегировать более простым способом. Меньший масштаб объема также относится к типичному объему — хотя с помощью метрик тоже можно получить большие объемы, но это все же несколько сложнее, чем с помощью логов и трассировок.](https://github.com/philyuchkoff/observability/blob/main/images/primary-signals.png)
> На рисунке 1 показаны три основных сигнала. Обратите внимание, что не все метрики семантически агрегируемы, но обычно их можно агрегировать более простым способом. Меньший масштаб объема также относится к типичному объему — хотя с помощью метрик тоже можно получить большие объемы, но это все же несколько сложнее, чем с помощью логов и трассировок.

Существуют различные способы сбора и обработки сигналов. У них разные требования к ресурсам, необходимым для сбора, хранения и анализа, при этом отличаются и способы наблюдения за системой. Выбор конкретного способа или их всех — это всегда поиск оптимального компромисса, как и остальные задачи в проектировании. В следующих разделах мы подробнее остановимся на каждом типе сигналов. Начнем с общеизвестных метрик, логов и трассировок и закончим профилями приложения и дампами сбоев.

